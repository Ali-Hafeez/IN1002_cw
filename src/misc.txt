private boolean isAssignmentSatisfiable(int[][] clauseDatabase, int[] assignment) {
        for (int[] clause : clauseDatabase) {
            boolean isClauseSatisfied = false;
            for (int literal : clause) {
                int variable = Math.abs(literal);
                if (assignment[variable] == 0) {
                    continue;
                }
                if (literal > 0 && assignment[variable] == 1) {
                    isClauseSatisfied = true;
                    break;
                }
                if (literal < 0 && assignment[variable] == -1) {
                    isClauseSatisfied = true;
                    break;
                }
            }
            if (!isClauseSatisfied) {
                return false;
            }
        }
        return true;
    }

















    private int[][] pureLiteralRule(int[][] clauseDatabase, int[] assignment) {
        boolean[] keepClauses = new boolean[clauseDatabase.length];
        Arrays.fill(keepClauses, true);


        for (int i = 1; i < assignment.length; i++) {
            if (assignment[i] == 0) {
                boolean positive = false;
                boolean negative = false;
                for (int[] clause : clauseDatabase) {
                    for (int literal : clause) {
                        if (Math.abs(literal) == i) {
                            if (literal > 0) {
                                positive = true;
                            } else {
                                negative = true;
                            }
                        }
                        if (positive && negative) {
                            break;
                        }
                    }
                    if (positive && negative) {
                        break;
                    }
                }
                if (positive ^ negative) {
                    int polarity = positive ? 1 : -1;
                    assignment[i] = polarity;
                    for (int j = 0; j < clauseDatabase.length; j++) {
                        if (keepClauses[j]) {
                            int[] clause = clauseDatabase[j];
                            for (int k = 0; k < clause.length; k++) {
                                if (Math.abs(clause[k]) == i && clause[k] != polarity) {
                                    keepClauses[j] = false;
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }

        int numClauses = 0;
        for (int i = 0; i < clauseDatabase.length; i++) {
            if (keepClauses[i]) numClauses++;
        }
        int[][] newClauseDatabase = new int[numClauses][];
        int index = 0;
        for (int i = 0; i < clauseDatabase.length; i++) {
            if (keepClauses[i]) {
                newClauseDatabase[index] = clauseDatabase[i];
                index++;
            }
        }
        return newClauseDatabase;
    }
    public int[][] preprocess(int[][] clauseDatabase,int[]assignment) {
        boolean[] keepClauses = new boolean[clauseDatabase.length]; // initialize a boolean array to keep track of which clauses to keep
        Arrays.fill(keepClauses, true); // set all values to true initially

        // remove redundant clauses
        for (int i = 0; i < clauseDatabase.length; i++) {
            if (!keepClauses[i]) continue; // if the clause has already been marked for removal, skip it
            for (int j = i+1; j < clauseDatabase.length; j++) {
                if (!keepClauses[j]) continue; // if the clause has already been marked for removal, skip it
                if (Arrays.equals(clauseDatabase[i], clauseDatabase[j])) { // if two clauses are identical, mark one for removal
                    keepClauses[j] = false;
                }
            }
        }

        // remove unit clauses
        boolean unitClauseFound = true;
        while (unitClauseFound) {
            unitClauseFound = false;
            for (int i = 0; i < clauseDatabase.length; i++) {
                if (!keepClauses[i]) continue; // if the clause has already been marked for removal, skip it
                if (clauseDatabase[i].length == 1) { // if a clause has length 1, it is a unit clause
                    int lit = clauseDatabase[i][0];
                    if (assignment[Math.abs(lit)] == 0) { // if the variable in the unit clause has not been assigned yet, assign it
                        assignment[Math.abs(lit)] = lit > 0 ? 1 : -1;
                        unitClauseFound = true;
                        keepClauses[i] = false; // mark the unit clause for removal
                    } else if (assignment[Math.abs(lit)] != (lit > 0 ? 1 : -1)) { // if the variable has already been assigned but not to the value in the unit clause, the clause is unsatisfiable
                        return null;
                    }
                }
            }
        }

        // count the number of remaining clauses and create a new clause database with only those clauses
        int numClauses = 0;
        for (int i = 0; i < clauseDatabase.length; i++) {
            if (keepClauses[i]) numClauses++;
        }
        int[][] newClauseDatabase = new int[numClauses][];
        int index = 0;
        for (int i = 0; i < clauseDatabase.length; i++) {
            if (keepClauses[i]) {
                newClauseDatabase[index] = clauseDatabase[i];
                index++;
            }
        }
        return newClauseDatabase;
    }



    //data/220019969-clause-database-01.cnf
    int[] checkSat(int[][] clauseDatabase) {
        int numVariables = getNumVariables(clauseDatabase);
        int[] assignment = new int[numVariables + 1];
        int[][] newdata = pureLiteralRule(preprocess(clauseDatabase,assignment),assignment);
        return dpll(newdata, assignment,1)? assignment : null;
    }

    private boolean dpll(int[][] clauseDatabase, int[] assignment, int variable) {
        if (variable == assignment.length) {
            return isAssignmentSatisfiable(clauseDatabase, assignment);
        }

        assignment[variable] = 1;
        if (dpll(clauseDatabase, assignment, variable + 1)) {
            return true;
        }

        assignment[variable] = -1;
        return dpll(clauseDatabase, assignment, variable + 1);
    }


    private int getNumVariables(int[][] clauseDatabase) {
        int numVariables = 0;
        for (int[] clause : clauseDatabase) {
            for (int literal : clause) {
                int variable = Math.abs(literal);
                if (variable > numVariables) {
                    numVariables = variable;
                }
            }
        }
        return numVariables;
    }
    private boolean isAssignmentSatisfiable(int[][] clauseDatabase, int[] assignment) {
        boolean[] keepClauses = new boolean[clauseDatabase.length];
        Arrays.fill(keepClauses, true);
        int[] watchedLiteral = new int[clauseDatabase.length];
        Arrays.fill(watchedLiteral, -1);

        while (true) {
            boolean modified = false;

            // check if any clause is empty
            for (int i = 0; i < clauseDatabase.length; i++) {
                if (!keepClauses[i]) continue; // if the clause has already been marked for removal, skip it
                int trueLiteralCount = 0;
                int unassignedLiteral = -1;
                for (int j = 0; j < clauseDatabase[i].length; j++) {
                    int literal = clauseDatabase[i][j];
                    if (assignment[Math.abs(literal)] == 0) { // if the literal is unassigned
                        unassignedLiteral = literal;
                    } else if (assignment[Math.abs(literal)] == (literal > 0 ? 1 : -1)) { // if the literal is true
                        trueLiteralCount++;
                        if (watchedLiteral[i] == -1) {
                            watchedLiteral[i] = literal;
                        } else if (watchedLiteral[i] != -1 && literal != watchedLiteral[i]) {
                            watchedLiteral[i] = literal;
                        }
                        if (trueLiteralCount == 2) {
                            break;
                        }
                    }
                }
                if (trueLiteralCount == 0 && unassignedLiteral == -1) { // if the clause is empty
                    return false;
                } else if (trueLiteralCount == 1 && unassignedLiteral != -1) { // if the clause has a unit literal
                    assignment[Math.abs(unassignedLiteral)] = unassignedLiteral > 0 ? 1 : -1;
                    watchedLiteral[i] = unassignedLiteral;
                    modified = true;
                } else if (trueLiteralCount == 2 && unassignedLiteral != -1) {
                    int otherLiteral = watchedLiteral[i] == clauseDatabase[i][0] ? clauseDatabase[i][1] : clauseDatabase[i][0];
                    if (assignment[Math.abs(otherLiteral)] == 0) {
                        assignment[Math.abs(unassignedLiteral)] = unassignedLiteral > 0 ? 1 : -1;
                        watchedLiteral[i] = unassignedLiteral;
                        modified = true;
                    } else if (assignment[Math.abs(otherLiteral)] != (otherLiteral > 0 ? 1 : -1)) {
                        int[] tempClause = new int[2];
                        tempClause[0] = unassignedLiteral;
                        tempClause[1] = otherLiteral;
                        clauseDatabase[clauseDatabase.length - 1] = tempClause;
                        keepClauses[clauseDatabase.length - 1] = true;
                        watchedLiteral[clauseDatabase.length - 1] = otherLiteral;
                        modified = true;
                    }
                }
            }

            // remove redundant clauses
            for (int i = 0; i < clauseDatabase.length; i++) {
                if (!keepClauses[i]) continue; // if the clause has already been marked for removal, skip it
                for (int j = i+1; j < clauseDatabase.length; j++) {
                    if (!keepClauses[j]) continue; // if the clause has already been marked for removal, skip it
                    if (Arrays.equals(clauseDatabase[i], clauseDatabase[j])) { // if the two clauses are the same
                        keepClauses[j] = false;
                        modified = true;
                    } else if (watchedLiteral[i] == -clauseDatabase[j][0] && watchedLiteral[j] == -clauseDatabase[i][0]) { // if the two clauses can be resolved
                        int[] newClause = new int[clauseDatabase[i].length + clauseDatabase[j].length - 2];
                        int index = 0;
                        for (int k = 0; k < clauseDatabase[i].length; k++) {
                            if (clauseDatabase[i][k] != -watchedLiteral[i]) {
                                newClause[index++] = clauseDatabase[i][k];
                            }
                        }
                        for (int k = 0; k < clauseDatabase[j].length; k++) {
                            if (clauseDatabase[j][k] != -watchedLiteral[j]) {
                                newClause[index++] = clauseDatabase[j][k];
                            }
                        }
                        clauseDatabase[clauseDatabase.length - 1] = newClause;
                        keepClauses[clauseDatabase.length - 1] = true;
                        watchedLiteral[clauseDatabase.length - 1] = newClause[0];
                        modified = true;
                    }
                }
            }
            if (!modified) {
                return true;
            }
        }
    }

